/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "trade_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SF { namespace TRADE { namespace THRIFT {

int _kSocialNetTypeValues[] = {
  SocialNetType::FB,
  SocialNetType::Twitter,
  SocialNetType::GooglePlus
};
const char* _kSocialNetTypeNames[] = {
  "FB",
  "Twitter",
  "GooglePlus"
};
const std::map<int, const char*> _SocialNetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSocialNetTypeValues, _kSocialNetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SocialNetType::type& val) {
  std::map<int, const char*>::const_iterator it = _SocialNetType_VALUES_TO_NAMES.find(val);
  if (it != _SocialNetType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kPrivilegeLevelValues[] = {
  PrivilegeLevel::Normal,
  PrivilegeLevel::Premium,
  PrivilegeLevel::Support,
  PrivilegeLevel::Admin
};
const char* _kPrivilegeLevelNames[] = {
  "Normal",
  "Premium",
  "Support",
  "Admin"
};
const std::map<int, const char*> _PrivilegeLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPrivilegeLevelValues, _kPrivilegeLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PrivilegeLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _PrivilegeLevel_VALUES_TO_NAMES.find(val);
  if (it != _PrivilegeLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kOrderStateValues[] = {
  OrderState::Pending,
  OrderState::Open,
  OrderState::Closed,
  OrderState::Deleted,
  OrderState::Canceled,
  OrderState::Rejected,
  OrderState::Expired
};
const char* _kOrderStateNames[] = {
  "Pending",
  "Open",
  "Closed",
  "Deleted",
  "Canceled",
  "Rejected",
  "Expired"
};
const std::map<int, const char*> _OrderState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kOrderStateValues, _kOrderStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const OrderState::type& val) {
  std::map<int, const char*>::const_iterator it = _OrderState_VALUES_TO_NAMES.find(val);
  if (it != _OrderState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kOrderTypeValues[] = {
  OrderType::Buy,
  OrderType::Sell,
  OrderType::BuyLimit,
  OrderType::SellLimit,
  OrderType::BuyStop,
  OrderType::SellStop
};
const char* _kOrderTypeNames[] = {
  "Buy",
  "Sell",
  "BuyLimit",
  "SellLimit",
  "BuyStop",
  "SellStop"
};
const std::map<int, const char*> _OrderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kOrderTypeValues, _kOrderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const OrderType::type& val) {
  std::map<int, const char*>::const_iterator it = _OrderType_VALUES_TO_NAMES.find(val);
  if (it != _OrderType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTransactionStateValues[] = {
  TransactionState::Open,
  TransactionState::Closed,
  TransactionState::Canceled
};
const char* _kTransactionStateNames[] = {
  "Open",
  "Closed",
  "Canceled"
};
const std::map<int, const char*> _TransactionState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTransactionStateValues, _kTransactionStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TransactionState::type& val) {
  std::map<int, const char*>::const_iterator it = _TransactionState_VALUES_TO_NAMES.find(val);
  if (it != _TransactionState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TradeException::~TradeException() throw() {
}


void TradeException::__set_why(const std::string& val) {
  this->why = val;
}
std::ostream& operator<<(std::ostream& out, const TradeException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TradeException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TradeException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TradeException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TradeException &a, TradeException &b) {
  using ::std::swap;
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

TradeException::TradeException(const TradeException& other0) : TException() {
  why = other0.why;
  __isset = other0.__isset;
}
TradeException& TradeException::operator=(const TradeException& other1) {
  why = other1.why;
  __isset = other1.__isset;
  return *this;
}
void TradeException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TradeException(";
  out << "why=" << to_string(why);
  out << ")";
}

const char* TradeException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TradeException";
  }
}


Location::~Location() throw() {
}


void Location::__set_latitude(const double val) {
  this->latitude = val;
}

void Location::__set_longitude(const double val) {
  this->longitude = val;
}
std::ostream& operator<<(std::ostream& out, const Location& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Location::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->latitude);
          this->__isset.latitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->longitude);
          this->__isset.longitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Location::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Location");

  xfer += oprot->writeFieldBegin("latitude", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->latitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("longitude", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->longitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Location &a, Location &b) {
  using ::std::swap;
  swap(a.latitude, b.latitude);
  swap(a.longitude, b.longitude);
  swap(a.__isset, b.__isset);
}

Location::Location(const Location& other2) {
  latitude = other2.latitude;
  longitude = other2.longitude;
  __isset = other2.__isset;
}
Location& Location::operator=(const Location& other3) {
  latitude = other3.latitude;
  longitude = other3.longitude;
  __isset = other3.__isset;
  return *this;
}
void Location::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Location(";
  out << "latitude=" << to_string(latitude);
  out << ", " << "longitude=" << to_string(longitude);
  out << ")";
}


SocialNet::~SocialNet() throw() {
}


void SocialNet::__set_type(const SocialNetType::type val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const SocialNet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SocialNet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->type = (SocialNetType::type)ecast4;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SocialNet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SocialNet");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SocialNet &a, SocialNet &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

SocialNet::SocialNet(const SocialNet& other5) {
  type = other5.type;
  __isset = other5.__isset;
}
SocialNet& SocialNet::operator=(const SocialNet& other6) {
  type = other6.type;
  __isset = other6.__isset;
  return *this;
}
void SocialNet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SocialNet(";
  out << "type=" << to_string(type);
  out << ")";
}


Symbol::~Symbol() throw() {
}


void Symbol::__set_name(const std::string& val) {
  this->name = val;
}

void Symbol::__set_measure(const std::string& val) {
  this->measure = val;
}

void Symbol::__set_tags(const std::set<std::string> & val) {
  this->tags = val;
}

void Symbol::__set_kv(const std::map<std::string, std::string> & val) {
  this->kv = val;
}
std::ostream& operator<<(std::ostream& out, const Symbol& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Symbol::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measure);
          this->__isset.measure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->tags.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readSetBegin(_etype10, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _elem12;
              xfer += iprot->readString(_elem12);
              this->tags.insert(_elem12);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kv.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _ktype14;
            ::apache::thrift::protocol::TType _vtype15;
            xfer += iprot->readMapBegin(_ktype14, _vtype15, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _key18;
              xfer += iprot->readString(_key18);
              std::string& _val19 = this->kv[_key18];
              xfer += iprot->readString(_val19);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.kv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Symbol::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Symbol");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measure", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->measure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
    std::set<std::string> ::const_iterator _iter20;
    for (_iter20 = this->tags.begin(); _iter20 != this->tags.end(); ++_iter20)
    {
      xfer += oprot->writeString((*_iter20));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kv", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kv.size()));
    std::map<std::string, std::string> ::const_iterator _iter21;
    for (_iter21 = this->kv.begin(); _iter21 != this->kv.end(); ++_iter21)
    {
      xfer += oprot->writeString(_iter21->first);
      xfer += oprot->writeString(_iter21->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Symbol &a, Symbol &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.measure, b.measure);
  swap(a.tags, b.tags);
  swap(a.kv, b.kv);
  swap(a.__isset, b.__isset);
}

Symbol::Symbol(const Symbol& other22) {
  name = other22.name;
  measure = other22.measure;
  tags = other22.tags;
  kv = other22.kv;
  __isset = other22.__isset;
}
Symbol& Symbol::operator=(const Symbol& other23) {
  name = other23.name;
  measure = other23.measure;
  tags = other23.tags;
  kv = other23.kv;
  __isset = other23.__isset;
  return *this;
}
void Symbol::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Symbol(";
  out << "name=" << to_string(name);
  out << ", " << "measure=" << to_string(measure);
  out << ", " << "tags=" << to_string(tags);
  out << ", " << "kv=" << to_string(kv);
  out << ")";
}


Wallet::~Wallet() throw() {
}


void Wallet::__set_name(const std::string& val) {
  this->name = val;
}

void Wallet::__set_currency(const Symbol& val) {
  this->currency = val;
}

void Wallet::__set_volume(const Volume val) {
  this->volume = val;
}
std::ostream& operator<<(std::ostream& out, const Wallet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Wallet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->currency.read(iprot);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->volume);
          this->__isset.volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Wallet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Wallet");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->currency.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("volume", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Wallet &a, Wallet &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.currency, b.currency);
  swap(a.volume, b.volume);
  swap(a.__isset, b.__isset);
}

Wallet::Wallet(const Wallet& other24) {
  name = other24.name;
  currency = other24.currency;
  volume = other24.volume;
  __isset = other24.__isset;
}
Wallet& Wallet::operator=(const Wallet& other25) {
  name = other25.name;
  currency = other25.currency;
  volume = other25.volume;
  __isset = other25.__isset;
  return *this;
}
void Wallet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Wallet(";
  out << "name=" << to_string(name);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "volume=" << to_string(volume);
  out << ")";
}


UserAttributes::~UserAttributes() throw() {
}


void UserAttributes::__set_loc(const Location& val) {
  this->loc = val;
}

void UserAttributes::__set_active(const bool val) {
  this->active = val;
}

void UserAttributes::__set_social(const std::map<std::string, SocialNet> & val) {
  this->social = val;
}
std::ostream& operator<<(std::ostream& out, const UserAttributes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UserAttributes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->loc.read(iprot);
          this->__isset.loc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->active);
          this->__isset.active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->social.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              std::string _key31;
              xfer += iprot->readString(_key31);
              SocialNet& _val32 = this->social[_key31];
              xfer += _val32.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.social = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserAttributes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserAttributes");

  xfer += oprot->writeFieldBegin("loc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->loc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("social", ::apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->social.size()));
    std::map<std::string, SocialNet> ::const_iterator _iter33;
    for (_iter33 = this->social.begin(); _iter33 != this->social.end(); ++_iter33)
    {
      xfer += oprot->writeString(_iter33->first);
      xfer += _iter33->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserAttributes &a, UserAttributes &b) {
  using ::std::swap;
  swap(a.loc, b.loc);
  swap(a.active, b.active);
  swap(a.social, b.social);
  swap(a.__isset, b.__isset);
}

UserAttributes::UserAttributes(const UserAttributes& other34) {
  loc = other34.loc;
  active = other34.active;
  social = other34.social;
  __isset = other34.__isset;
}
UserAttributes& UserAttributes::operator=(const UserAttributes& other35) {
  loc = other35.loc;
  active = other35.active;
  social = other35.social;
  __isset = other35.__isset;
  return *this;
}
void UserAttributes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserAttributes(";
  out << "loc=" << to_string(loc);
  out << ", " << "active=" << to_string(active);
  out << ", " << "social=" << to_string(social);
  out << ")";
}


User::~User() throw() {
}


void User::__set_id(const ID val) {
  this->id = val;
}

void User::__set_username(const std::string& val) {
  this->username = val;
}

void User::__set_kv(const std::map<std::string, std::string> & val) {
  this->kv = val;
}

void User::__set_kvs(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->kvs = val;
}

void User::__set_wallets(const std::map<Symbol, Wallet> & val) {
  this->wallets = val;
}

void User::__set_level(const PrivilegeLevel::type val) {
  this->level = val;
}

void User::__set_attributes(const UserAttributes& val) {
  this->attributes = val;
}
std::ostream& operator<<(std::ostream& out, const User& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t User::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kv.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _ktype37;
            ::apache::thrift::protocol::TType _vtype38;
            xfer += iprot->readMapBegin(_ktype37, _vtype38, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              std::string _key41;
              xfer += iprot->readString(_key41);
              std::string& _val42 = this->kv[_key41];
              xfer += iprot->readString(_val42);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.kv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kvs.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              std::map<std::string, std::string> & _val49 = this->kvs[_key48];
              {
                _val49.clear();
                uint32_t _size50;
                ::apache::thrift::protocol::TType _ktype51;
                ::apache::thrift::protocol::TType _vtype52;
                xfer += iprot->readMapBegin(_ktype51, _vtype52, _size50);
                uint32_t _i54;
                for (_i54 = 0; _i54 < _size50; ++_i54)
                {
                  std::string _key55;
                  xfer += iprot->readString(_key55);
                  std::string& _val56 = _val49[_key55];
                  xfer += iprot->readString(_val56);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.kvs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->wallets.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              Symbol _key62;
              xfer += _key62.read(iprot);
              Wallet& _val63 = this->wallets[_key62];
              xfer += _val63.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 51:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->level = (PrivilegeLevel::type)ecast64;
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 61:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attributes.read(iprot);
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t User::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("User");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kv", ::apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kv.size()));
    std::map<std::string, std::string> ::const_iterator _iter65;
    for (_iter65 = this->kv.begin(); _iter65 != this->kv.end(); ++_iter65)
    {
      xfer += oprot->writeString(_iter65->first);
      xfer += oprot->writeString(_iter65->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 31);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->kvs.size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter66;
    for (_iter66 = this->kvs.begin(); _iter66 != this->kvs.end(); ++_iter66)
    {
      xfer += oprot->writeString(_iter66->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter66->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter67;
        for (_iter67 = _iter66->second.begin(); _iter67 != _iter66->second.end(); ++_iter67)
        {
          xfer += oprot->writeString(_iter67->first);
          xfer += oprot->writeString(_iter67->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallets", ::apache::thrift::protocol::T_MAP, 41);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->wallets.size()));
    std::map<Symbol, Wallet> ::const_iterator _iter68;
    for (_iter68 = this->wallets.begin(); _iter68 != this->wallets.end(); ++_iter68)
    {
      xfer += _iter68->first.write(oprot);
      xfer += _iter68->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 51);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_STRUCT, 61);
  xfer += this->attributes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(User &a, User &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.username, b.username);
  swap(a.kv, b.kv);
  swap(a.kvs, b.kvs);
  swap(a.wallets, b.wallets);
  swap(a.level, b.level);
  swap(a.attributes, b.attributes);
  swap(a.__isset, b.__isset);
}

User::User(const User& other69) {
  id = other69.id;
  username = other69.username;
  kv = other69.kv;
  kvs = other69.kvs;
  wallets = other69.wallets;
  level = other69.level;
  attributes = other69.attributes;
  __isset = other69.__isset;
}
User& User::operator=(const User& other70) {
  id = other70.id;
  username = other70.username;
  kv = other70.kv;
  kvs = other70.kvs;
  wallets = other70.wallets;
  level = other70.level;
  attributes = other70.attributes;
  __isset = other70.__isset;
  return *this;
}
void User::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "User(";
  out << "id=" << to_string(id);
  out << ", " << "username=" << to_string(username);
  out << ", " << "kv=" << to_string(kv);
  out << ", " << "kvs=" << to_string(kvs);
  out << ", " << "wallets=" << to_string(wallets);
  out << ", " << "level=" << to_string(level);
  out << ", " << "attributes=" << to_string(attributes);
  out << ")";
}


Order::~Order() throw() {
}


void Order::__set_id(const ID val) {
  this->id = val;
}

void Order::__set_symbol(const Symbol& val) {
  this->symbol = val;
}

void Order::__set_symbolDst(const Symbol& val) {
  this->symbolDst = val;
}

void Order::__set_price(const Price val) {
  this->price = val;
}

void Order::__set_takeProfit(const Price val) {
  this->takeProfit = val;
}

void Order::__set_stopLoss(const Price val) {
  this->stopLoss = val;
}

void Order::__set_swap(const Price val) {
  this->swap = val;
}

void Order::__set_profit(const Price val) {
  this->profit = val;
}

void Order::__set_volume(const Volume val) {
  this->volume = val;
}

void Order::__set_time(const std::map<OrderState::type, Timestamp> & val) {
  this->time = val;
}

void Order::__set_state(const OrderState::type val) {
  this->state = val;
}

void Order::__set_type(const OrderType::type val) {
  this->type = val;
}

void Order::__set_user(const User& val) {
  this->user = val;
}
std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->symbol.read(iprot);
          this->__isset.symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->symbolDst.read(iprot);
          this->__isset.symbolDst = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->takeProfit);
          this->__isset.takeProfit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stopLoss);
          this->__isset.stopLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->swap);
          this->__isset.swap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->profit);
          this->__isset.profit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->volume);
          this->__isset.volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->time.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _ktype72;
            ::apache::thrift::protocol::TType _vtype73;
            xfer += iprot->readMapBegin(_ktype72, _vtype73, _size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              OrderState::type _key76;
              int32_t ecast78;
              xfer += iprot->readI32(ecast78);
              _key76 = (OrderState::type)ecast78;
              Timestamp& _val77 = this->time[_key76];
              xfer += iprot->readI64(_val77);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 51:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->state = (OrderState::type)ecast79;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 52:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast80;
          xfer += iprot->readI32(ecast80);
          this->type = (OrderType::type)ecast80;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 61:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user.read(iprot);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->symbol.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbolDst", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->symbolDst.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("takeProfit", ::apache::thrift::protocol::T_I64, 22);
  xfer += oprot->writeI64(this->takeProfit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopLoss", ::apache::thrift::protocol::T_I64, 23);
  xfer += oprot->writeI64(this->stopLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("swap", ::apache::thrift::protocol::T_I64, 24);
  xfer += oprot->writeI64(this->swap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("profit", ::apache::thrift::protocol::T_I64, 25);
  xfer += oprot->writeI64(this->profit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("volume", ::apache::thrift::protocol::T_I64, 31);
  xfer += oprot->writeI64(this->volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_MAP, 41);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->time.size()));
    std::map<OrderState::type, Timestamp> ::const_iterator _iter81;
    for (_iter81 = this->time.begin(); _iter81 != this->time.end(); ++_iter81)
    {
      xfer += oprot->writeI32((int32_t)_iter81->first);
      xfer += oprot->writeI64(_iter81->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 51);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 52);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRUCT, 61);
  xfer += this->user.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.symbol, b.symbol);
  swap(a.symbolDst, b.symbolDst);
  swap(a.price, b.price);
  swap(a.takeProfit, b.takeProfit);
  swap(a.stopLoss, b.stopLoss);
  swap(a.swap, b.swap);
  swap(a.profit, b.profit);
  swap(a.volume, b.volume);
  swap(a.time, b.time);
  swap(a.state, b.state);
  swap(a.type, b.type);
  swap(a.user, b.user);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other82) {
  id = other82.id;
  symbol = other82.symbol;
  symbolDst = other82.symbolDst;
  price = other82.price;
  takeProfit = other82.takeProfit;
  stopLoss = other82.stopLoss;
  swap = other82.swap;
  profit = other82.profit;
  volume = other82.volume;
  time = other82.time;
  state = other82.state;
  type = other82.type;
  user = other82.user;
  __isset = other82.__isset;
}
Order& Order::operator=(const Order& other83) {
  id = other83.id;
  symbol = other83.symbol;
  symbolDst = other83.symbolDst;
  price = other83.price;
  takeProfit = other83.takeProfit;
  stopLoss = other83.stopLoss;
  swap = other83.swap;
  profit = other83.profit;
  volume = other83.volume;
  time = other83.time;
  state = other83.state;
  type = other83.type;
  user = other83.user;
  __isset = other83.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "id=" << to_string(id);
  out << ", " << "symbol=" << to_string(symbol);
  out << ", " << "symbolDst=" << to_string(symbolDst);
  out << ", " << "price=" << to_string(price);
  out << ", " << "takeProfit=" << to_string(takeProfit);
  out << ", " << "stopLoss=" << to_string(stopLoss);
  out << ", " << "swap=" << to_string(swap);
  out << ", " << "profit=" << to_string(profit);
  out << ", " << "volume=" << to_string(volume);
  out << ", " << "time=" << to_string(time);
  out << ", " << "state=" << to_string(state);
  out << ", " << "type=" << to_string(type);
  out << ", " << "user=" << to_string(user);
  out << ")";
}


Transaction::~Transaction() throw() {
}


void Transaction::__set_id(const ID val) {
  this->id = val;
}

void Transaction::__set_sell(const Order& val) {
  this->sell = val;
}

void Transaction::__set_buy(const Order& val) {
  this->buy = val;
}

void Transaction::__set_price(const Price val) {
  this->price = val;
}

void Transaction::__set_volume(const Volume val) {
  this->volume = val;
}

void Transaction::__set_state(const TransactionState::type val) {
  this->state = val;
}

void Transaction::__set_time(const std::map<TransactionState::type, Timestamp> & val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const Transaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Transaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sell.read(iprot);
          this->__isset.sell = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->buy.read(iprot);
          this->__isset.buy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->volume);
          this->__isset.volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 51:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast84;
          xfer += iprot->readI32(ecast84);
          this->state = (TransactionState::type)ecast84;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 61:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->time.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _ktype86;
            ::apache::thrift::protocol::TType _vtype87;
            xfer += iprot->readMapBegin(_ktype86, _vtype87, _size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              TransactionState::type _key90;
              int32_t ecast92;
              xfer += iprot->readI32(ecast92);
              _key90 = (TransactionState::type)ecast92;
              Timestamp& _val91 = this->time[_key90];
              xfer += iprot->readI64(_val91);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Transaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Transaction");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sell", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->sell.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buy", ::apache::thrift::protocol::T_STRUCT, 21);
  xfer += this->buy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I64, 31);
  xfer += oprot->writeI64(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("volume", ::apache::thrift::protocol::T_I64, 41);
  xfer += oprot->writeI64(this->volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 51);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_MAP, 61);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->time.size()));
    std::map<TransactionState::type, Timestamp> ::const_iterator _iter93;
    for (_iter93 = this->time.begin(); _iter93 != this->time.end(); ++_iter93)
    {
      xfer += oprot->writeI32((int32_t)_iter93->first);
      xfer += oprot->writeI64(_iter93->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Transaction &a, Transaction &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sell, b.sell);
  swap(a.buy, b.buy);
  swap(a.price, b.price);
  swap(a.volume, b.volume);
  swap(a.state, b.state);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

Transaction::Transaction(const Transaction& other94) {
  id = other94.id;
  sell = other94.sell;
  buy = other94.buy;
  price = other94.price;
  volume = other94.volume;
  state = other94.state;
  time = other94.time;
  __isset = other94.__isset;
}
Transaction& Transaction::operator=(const Transaction& other95) {
  id = other95.id;
  sell = other95.sell;
  buy = other95.buy;
  price = other95.price;
  volume = other95.volume;
  state = other95.state;
  time = other95.time;
  __isset = other95.__isset;
  return *this;
}
void Transaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Transaction(";
  out << "id=" << to_string(id);
  out << ", " << "sell=" << to_string(sell);
  out << ", " << "buy=" << to_string(buy);
  out << ", " << "price=" << to_string(price);
  out << ", " << "volume=" << to_string(volume);
  out << ", " << "state=" << to_string(state);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


MarketData::~MarketData() throw() {
}


void MarketData::__set_symbol(const Symbol& val) {
  this->symbol = val;
}

void MarketData::__set_price(const std::map<std::string, double> & val) {
  this->price = val;
}

void MarketData::__set_volume(const double val) {
  this->volume = val;
}

void MarketData::__set_timestamp(const Timestamp val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const MarketData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MarketData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->symbol.read(iprot);
          this->__isset.symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->price.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _ktype97;
            ::apache::thrift::protocol::TType _vtype98;
            xfer += iprot->readMapBegin(_ktype97, _vtype98, _size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              std::string _key101;
              xfer += iprot->readString(_key101);
              double& _val102 = this->price[_key101];
              xfer += iprot->readDouble(_val102);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->volume);
          this->__isset.volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarketData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MarketData");

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->symbol.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->price.size()));
    std::map<std::string, double> ::const_iterator _iter103;
    for (_iter103 = this->price.begin(); _iter103 != this->price.end(); ++_iter103)
    {
      xfer += oprot->writeString(_iter103->first);
      xfer += oprot->writeDouble(_iter103->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("volume", ::apache::thrift::protocol::T_DOUBLE, 31);
  xfer += oprot->writeDouble(this->volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 41);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarketData &a, MarketData &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.price, b.price);
  swap(a.volume, b.volume);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

MarketData::MarketData(const MarketData& other104) {
  symbol = other104.symbol;
  price = other104.price;
  volume = other104.volume;
  timestamp = other104.timestamp;
  __isset = other104.__isset;
}
MarketData& MarketData::operator=(const MarketData& other105) {
  symbol = other105.symbol;
  price = other105.price;
  volume = other105.volume;
  timestamp = other105.timestamp;
  __isset = other105.__isset;
  return *this;
}
void MarketData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MarketData(";
  out << "symbol=" << to_string(symbol);
  out << ", " << "price=" << to_string(price);
  out << ", " << "volume=" << to_string(volume);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


OrderBook::~OrderBook() throw() {
}


void OrderBook::__set_id(const int64_t val) {
  this->id = val;
}

void OrderBook::__set_ordersOpen(const TOrdersFull& val) {
  this->ordersOpen = val;
}

void OrderBook::__set_orders(const std::map<std::string, TOrders> & val) {
  this->orders = val;
}

void OrderBook::__set_orderIdx(const std::map<std::string, IdIdx> & val) {
  this->orderIdx = val;
}

void OrderBook::__set_transactions(const std::map<std::string, TTransactions> & val) {
  this->transactions = val;
}

void OrderBook::__set_md(const std::map<std::string, TMarketDataPoint> & val) {
  this->md = val;
}
std::ostream& operator<<(std::ostream& out, const OrderBook& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OrderBook::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ordersOpen.clear();
            uint32_t _size106;
            ::apache::thrift::protocol::TType _ktype107;
            ::apache::thrift::protocol::TType _vtype108;
            xfer += iprot->readMapBegin(_ktype107, _vtype108, _size106);
            uint32_t _i110;
            for (_i110 = 0; _i110 < _size106; ++_i110)
            {
              Symbol _key111;
              xfer += _key111.read(iprot);
              std::map<Symbol, std::map<OrderType::type, TOrders> > & _val112 = this->ordersOpen[_key111];
              {
                _val112.clear();
                uint32_t _size113;
                ::apache::thrift::protocol::TType _ktype114;
                ::apache::thrift::protocol::TType _vtype115;
                xfer += iprot->readMapBegin(_ktype114, _vtype115, _size113);
                uint32_t _i117;
                for (_i117 = 0; _i117 < _size113; ++_i117)
                {
                  Symbol _key118;
                  xfer += _key118.read(iprot);
                  std::map<OrderType::type, TOrders> & _val119 = _val112[_key118];
                  {
                    _val119.clear();
                    uint32_t _size120;
                    ::apache::thrift::protocol::TType _ktype121;
                    ::apache::thrift::protocol::TType _vtype122;
                    xfer += iprot->readMapBegin(_ktype121, _vtype122, _size120);
                    uint32_t _i124;
                    for (_i124 = 0; _i124 < _size120; ++_i124)
                    {
                      OrderType::type _key125;
                      int32_t ecast127;
                      xfer += iprot->readI32(ecast127);
                      _key125 = (OrderType::type)ecast127;
                      TOrders& _val126 = _val119[_key125];
                      {
                        _val126.clear();
                        uint32_t _size128;
                        ::apache::thrift::protocol::TType _etype131;
                        xfer += iprot->readListBegin(_etype131, _size128);
                        _val126.resize(_size128);
                        uint32_t _i132;
                        for (_i132 = 0; _i132 < _size128; ++_i132)
                        {
                          xfer += _val126[_i132].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ordersOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->orders.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _ktype134;
            ::apache::thrift::protocol::TType _vtype135;
            xfer += iprot->readMapBegin(_ktype134, _vtype135, _size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              std::string _key138;
              xfer += iprot->readString(_key138);
              TOrders& _val139 = this->orders[_key138];
              {
                _val139.clear();
                uint32_t _size140;
                ::apache::thrift::protocol::TType _etype143;
                xfer += iprot->readListBegin(_etype143, _size140);
                _val139.resize(_size140);
                uint32_t _i144;
                for (_i144 = 0; _i144 < _size140; ++_i144)
                {
                  xfer += _val139[_i144].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.orders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->orderIdx.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _ktype146;
            ::apache::thrift::protocol::TType _vtype147;
            xfer += iprot->readMapBegin(_ktype146, _vtype147, _size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              std::string _key150;
              xfer += iprot->readString(_key150);
              IdIdx& _val151 = this->orderIdx[_key150];
              {
                _val151.clear();
                uint32_t _size152;
                ::apache::thrift::protocol::TType _ktype153;
                ::apache::thrift::protocol::TType _vtype154;
                xfer += iprot->readMapBegin(_ktype153, _vtype154, _size152);
                uint32_t _i156;
                for (_i156 = 0; _i156 < _size152; ++_i156)
                {
                  int64_t _key157;
                  xfer += iprot->readI64(_key157);
                  int32_t& _val158 = _val151[_key157];
                  xfer += iprot->readI32(_val158);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.orderIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transactions.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _ktype160;
            ::apache::thrift::protocol::TType _vtype161;
            xfer += iprot->readMapBegin(_ktype160, _vtype161, _size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              std::string _key164;
              xfer += iprot->readString(_key164);
              TTransactions& _val165 = this->transactions[_key164];
              {
                _val165.clear();
                uint32_t _size166;
                ::apache::thrift::protocol::TType _etype169;
                xfer += iprot->readListBegin(_etype169, _size166);
                _val165.resize(_size166);
                uint32_t _i170;
                for (_i170 = 0; _i170 < _size166; ++_i170)
                {
                  xfer += _val165[_i170].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->md.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _ktype172;
            ::apache::thrift::protocol::TType _vtype173;
            xfer += iprot->readMapBegin(_ktype172, _vtype173, _size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              std::string _key176;
              xfer += iprot->readString(_key176);
              TMarketDataPoint& _val177 = this->md[_key176];
              {
                _val177.clear();
                uint32_t _size178;
                ::apache::thrift::protocol::TType _ktype179;
                ::apache::thrift::protocol::TType _vtype180;
                xfer += iprot->readMapBegin(_ktype179, _vtype180, _size178);
                uint32_t _i182;
                for (_i182 = 0; _i182 < _size178; ++_i182)
                {
                  Symbol _key183;
                  xfer += _key183.read(iprot);
                  MarketData& _val184 = _val177[_key183];
                  xfer += _val184.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.md = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OrderBook::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OrderBook");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ordersOpen", ::apache::thrift::protocol::T_MAP, 11);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->ordersOpen.size()));
    std::map<Symbol, std::map<Symbol, std::map<OrderType::type, TOrders> > > ::const_iterator _iter185;
    for (_iter185 = this->ordersOpen.begin(); _iter185 != this->ordersOpen.end(); ++_iter185)
    {
      xfer += _iter185->first.write(oprot);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter185->second.size()));
        std::map<Symbol, std::map<OrderType::type, TOrders> > ::const_iterator _iter186;
        for (_iter186 = _iter185->second.begin(); _iter186 != _iter185->second.end(); ++_iter186)
        {
          xfer += _iter186->first.write(oprot);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter186->second.size()));
            std::map<OrderType::type, TOrders> ::const_iterator _iter187;
            for (_iter187 = _iter186->second.begin(); _iter187 != _iter186->second.end(); ++_iter187)
            {
              xfer += oprot->writeI32((int32_t)_iter187->first);
              {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter187->second.size()));
                std::vector<Order> ::const_iterator _iter188;
                for (_iter188 = _iter187->second.begin(); _iter188 != _iter187->second.end(); ++_iter188)
                {
                  xfer += (*_iter188).write(oprot);
                }
                xfer += oprot->writeListEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orders", ::apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->orders.size()));
    std::map<std::string, TOrders> ::const_iterator _iter189;
    for (_iter189 = this->orders.begin(); _iter189 != this->orders.end(); ++_iter189)
    {
      xfer += oprot->writeString(_iter189->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter189->second.size()));
        std::vector<Order> ::const_iterator _iter190;
        for (_iter190 = _iter189->second.begin(); _iter190 != _iter189->second.end(); ++_iter190)
        {
          xfer += (*_iter190).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orderIdx", ::apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->orderIdx.size()));
    std::map<std::string, IdIdx> ::const_iterator _iter191;
    for (_iter191 = this->orderIdx.begin(); _iter191 != this->orderIdx.end(); ++_iter191)
    {
      xfer += oprot->writeString(_iter191->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter191->second.size()));
        std::map<int64_t, int32_t> ::const_iterator _iter192;
        for (_iter192 = _iter191->second.begin(); _iter192 != _iter191->second.end(); ++_iter192)
        {
          xfer += oprot->writeI64(_iter192->first);
          xfer += oprot->writeI32(_iter192->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_MAP, 31);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->transactions.size()));
    std::map<std::string, TTransactions> ::const_iterator _iter193;
    for (_iter193 = this->transactions.begin(); _iter193 != this->transactions.end(); ++_iter193)
    {
      xfer += oprot->writeString(_iter193->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter193->second.size()));
        std::vector<Transaction> ::const_iterator _iter194;
        for (_iter194 = _iter193->second.begin(); _iter194 != _iter193->second.end(); ++_iter194)
        {
          xfer += (*_iter194).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("md", ::apache::thrift::protocol::T_MAP, 41);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->md.size()));
    std::map<std::string, TMarketDataPoint> ::const_iterator _iter195;
    for (_iter195 = this->md.begin(); _iter195 != this->md.end(); ++_iter195)
    {
      xfer += oprot->writeString(_iter195->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter195->second.size()));
        std::map<Symbol, MarketData> ::const_iterator _iter196;
        for (_iter196 = _iter195->second.begin(); _iter196 != _iter195->second.end(); ++_iter196)
        {
          xfer += _iter196->first.write(oprot);
          xfer += _iter196->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OrderBook &a, OrderBook &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.ordersOpen, b.ordersOpen);
  swap(a.orders, b.orders);
  swap(a.orderIdx, b.orderIdx);
  swap(a.transactions, b.transactions);
  swap(a.md, b.md);
  swap(a.__isset, b.__isset);
}

OrderBook::OrderBook(const OrderBook& other197) {
  id = other197.id;
  ordersOpen = other197.ordersOpen;
  orders = other197.orders;
  orderIdx = other197.orderIdx;
  transactions = other197.transactions;
  md = other197.md;
  __isset = other197.__isset;
}
OrderBook& OrderBook::operator=(const OrderBook& other198) {
  id = other198.id;
  ordersOpen = other198.ordersOpen;
  orders = other198.orders;
  orderIdx = other198.orderIdx;
  transactions = other198.transactions;
  md = other198.md;
  __isset = other198.__isset;
  return *this;
}
void OrderBook::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OrderBook(";
  out << "id=" << to_string(id);
  out << ", " << "ordersOpen=" << to_string(ordersOpen);
  out << ", " << "orders=" << to_string(orders);
  out << ", " << "orderIdx=" << to_string(orderIdx);
  out << ", " << "transactions=" << to_string(transactions);
  out << ", " << "md=" << to_string(md);
  out << ")";
}


TMSpec::~TMSpec() throw() {
}


void TMSpec::__set_owner(const User& val) {
  this->owner = val;
}

void TMSpec::__set_type(const std::string& val) {
  this->type = val;
}

void TMSpec::__set_desc(const std::string& val) {
  this->desc = val;
}

void TMSpec::__set_host(const std::string& val) {
  this->host = val;
}

void TMSpec::__set_port(const int32_t val) {
  this->port = val;
}

void TMSpec::__set_cmd(const std::vector<std::string> & val) {
  this->cmd = val;
}

void TMSpec::__set_link(const std::string& val) {
  this->link = val;
}

void TMSpec::__set_guid(const Guid& val) {
  this->guid = val;
}

void TMSpec::__set_timeCreation(const Timestamp val) {
  this->timeCreation = val;
}
std::ostream& operator<<(std::ostream& out, const TMSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->owner.read(iprot);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          this->__isset.desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 51:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmd.clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _etype202;
            xfer += iprot->readListBegin(_etype202, _size199);
            this->cmd.resize(_size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              xfer += iprot->readString(this->cmd[_i203]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 61:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->link);
          this->__isset.link = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 71:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 81:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeCreation);
          this->__isset.timeCreation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMSpec");

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->owner.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 31);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 41);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 42);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_LIST, 51);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cmd.size()));
    std::vector<std::string> ::const_iterator _iter204;
    for (_iter204 = this->cmd.begin(); _iter204 != this->cmd.end(); ++_iter204)
    {
      xfer += oprot->writeString((*_iter204));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("link", ::apache::thrift::protocol::T_STRING, 61);
  xfer += oprot->writeString(this->link);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 71);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeCreation", ::apache::thrift::protocol::T_I64, 81);
  xfer += oprot->writeI64(this->timeCreation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMSpec &a, TMSpec &b) {
  using ::std::swap;
  swap(a.owner, b.owner);
  swap(a.type, b.type);
  swap(a.desc, b.desc);
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.cmd, b.cmd);
  swap(a.link, b.link);
  swap(a.guid, b.guid);
  swap(a.timeCreation, b.timeCreation);
  swap(a.__isset, b.__isset);
}

TMSpec::TMSpec(const TMSpec& other205) {
  owner = other205.owner;
  type = other205.type;
  desc = other205.desc;
  host = other205.host;
  port = other205.port;
  cmd = other205.cmd;
  link = other205.link;
  guid = other205.guid;
  timeCreation = other205.timeCreation;
  __isset = other205.__isset;
}
TMSpec& TMSpec::operator=(const TMSpec& other206) {
  owner = other206.owner;
  type = other206.type;
  desc = other206.desc;
  host = other206.host;
  port = other206.port;
  cmd = other206.cmd;
  link = other206.link;
  guid = other206.guid;
  timeCreation = other206.timeCreation;
  __isset = other206.__isset;
  return *this;
}
void TMSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMSpec(";
  out << "owner=" << to_string(owner);
  out << ", " << "type=" << to_string(type);
  out << ", " << "desc=" << to_string(desc);
  out << ", " << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "cmd=" << to_string(cmd);
  out << ", " << "link=" << to_string(link);
  out << ", " << "guid=" << to_string(guid);
  out << ", " << "timeCreation=" << to_string(timeCreation);
  out << ")";
}


TradeMachine::~TradeMachine() throw() {
}


void TradeMachine::__set_spec(const TMSpec& val) {
  this->spec = val;
}

void TradeMachine::__set_book(const OrderBook& val) {
  this->book = val;
}

void TradeMachine::__set_users(const std::vector<User> & val) {
  this->users = val;
}

void TradeMachine::__set_symbolsSrc(const std::vector<Symbol> & val) {
  this->symbolsSrc = val;
}

void TradeMachine::__set_symbolsDst(const std::vector<Symbol> & val) {
  this->symbolsDst = val;
}
std::ostream& operator<<(std::ostream& out, const TradeMachine& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TradeMachine::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec.read(iprot);
          this->__isset.spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->book.read(iprot);
          this->__isset.book = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->users.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->users.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += this->users[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.users = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->symbolsSrc.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->symbolsSrc.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += this->symbolsSrc[_i216].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.symbolsSrc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->symbolsDst.clear();
            uint32_t _size217;
            ::apache::thrift::protocol::TType _etype220;
            xfer += iprot->readListBegin(_etype220, _size217);
            this->symbolsDst.resize(_size217);
            uint32_t _i221;
            for (_i221 = 0; _i221 < _size217; ++_i221)
            {
              xfer += this->symbolsDst[_i221].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.symbolsDst = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TradeMachine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TradeMachine");

  xfer += oprot->writeFieldBegin("spec", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("book", ::apache::thrift::protocol::T_STRUCT, 21);
  xfer += this->book.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("users", ::apache::thrift::protocol::T_LIST, 31);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->users.size()));
    std::vector<User> ::const_iterator _iter222;
    for (_iter222 = this->users.begin(); _iter222 != this->users.end(); ++_iter222)
    {
      xfer += (*_iter222).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbolsSrc", ::apache::thrift::protocol::T_LIST, 41);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->symbolsSrc.size()));
    std::vector<Symbol> ::const_iterator _iter223;
    for (_iter223 = this->symbolsSrc.begin(); _iter223 != this->symbolsSrc.end(); ++_iter223)
    {
      xfer += (*_iter223).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbolsDst", ::apache::thrift::protocol::T_LIST, 42);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->symbolsDst.size()));
    std::vector<Symbol> ::const_iterator _iter224;
    for (_iter224 = this->symbolsDst.begin(); _iter224 != this->symbolsDst.end(); ++_iter224)
    {
      xfer += (*_iter224).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TradeMachine &a, TradeMachine &b) {
  using ::std::swap;
  swap(a.spec, b.spec);
  swap(a.book, b.book);
  swap(a.users, b.users);
  swap(a.symbolsSrc, b.symbolsSrc);
  swap(a.symbolsDst, b.symbolsDst);
  swap(a.__isset, b.__isset);
}

TradeMachine::TradeMachine(const TradeMachine& other225) {
  spec = other225.spec;
  book = other225.book;
  users = other225.users;
  symbolsSrc = other225.symbolsSrc;
  symbolsDst = other225.symbolsDst;
  __isset = other225.__isset;
}
TradeMachine& TradeMachine::operator=(const TradeMachine& other226) {
  spec = other226.spec;
  book = other226.book;
  users = other226.users;
  symbolsSrc = other226.symbolsSrc;
  symbolsDst = other226.symbolsDst;
  __isset = other226.__isset;
  return *this;
}
void TradeMachine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TradeMachine(";
  out << "spec=" << to_string(spec);
  out << ", " << "book=" << to_string(book);
  out << ", " << "users=" << to_string(users);
  out << ", " << "symbolsSrc=" << to_string(symbolsSrc);
  out << ", " << "symbolsDst=" << to_string(symbolsDst);
  out << ")";
}

}}} // namespace
