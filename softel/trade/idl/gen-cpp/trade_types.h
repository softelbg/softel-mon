/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef trade_TYPES_H
#define trade_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace SF { namespace TRADE { namespace THRIFT {

struct SocialNetType {
  enum type {
    FB = 0,
    Twitter = 1,
    GooglePlus = 2
  };
};

extern const std::map<int, const char*> _SocialNetType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SocialNetType::type& val);

struct PrivilegeLevel {
  enum type {
    Normal = 0,
    Premium = 1,
    Support = 2,
    Admin = 3
  };
};

extern const std::map<int, const char*> _PrivilegeLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PrivilegeLevel::type& val);

struct OrderState {
  enum type {
    Pending = 1,
    Open = 2,
    Closed = 4,
    Deleted = 8,
    Canceled = 16,
    Rejected = 32,
    Expired = 64
  };
};

extern const std::map<int, const char*> _OrderState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OrderState::type& val);

struct OrderType {
  enum type {
    Buy = 1,
    Sell = 2,
    BuyLimit = 4,
    SellLimit = 8,
    BuyStop = 16,
    SellStop = 32
  };
};

extern const std::map<int, const char*> _OrderType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OrderType::type& val);

struct TransactionState {
  enum type {
    Open = 0,
    Closed = 1,
    Canceled = 2
  };
};

extern const std::map<int, const char*> _TransactionState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TransactionState::type& val);

typedef int64_t Timestamp;

typedef int64_t Price;

typedef int64_t Volume;

typedef int64_t ID;

typedef std::string Guid;

typedef std::map<class Symbol, class MarketData>  TMarketDataPoint;

typedef std::map<std::string, TMarketDataPoint>  TMarketDataPointMap;

typedef std::vector<class Order>  TOrders;

typedef std::vector<class Symbol>  TSymbols;

typedef std::vector<class User>  TUsers;

typedef std::vector<class Transaction>  TTransactions;

typedef std::map<class Symbol, std::map<class Symbol, std::map<OrderType::type, TOrders> > >  TOrdersFull;

typedef std::map<int64_t, int32_t>  IdIdx;

class TradeException;

class Location;

class SocialNet;

class Symbol;

class Wallet;

class UserAttributes;

class User;

class Order;

class Transaction;

class MarketData;

class OrderBook;

class TMSpec;

class TradeMachine;

typedef struct _TradeException__isset {
  _TradeException__isset() : why(false) {}
  bool why :1;
} _TradeException__isset;

class TradeException : public ::apache::thrift::TException {
 public:

  TradeException(const TradeException&);
  TradeException& operator=(const TradeException&);
  TradeException() : why() {
  }

  virtual ~TradeException() throw();
  std::string why;

  _TradeException__isset __isset;

  void __set_why(const std::string& val);

  bool operator == (const TradeException & rhs) const
  {
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const TradeException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TradeException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(TradeException &a, TradeException &b);

std::ostream& operator<<(std::ostream& out, const TradeException& obj);

typedef struct _Location__isset {
  _Location__isset() : latitude(false), longitude(false) {}
  bool latitude :1;
  bool longitude :1;
} _Location__isset;

class Location : public virtual ::apache::thrift::TBase {
 public:

  Location(const Location&);
  Location& operator=(const Location&);
  Location() : latitude(0), longitude(0) {
  }

  virtual ~Location() throw();
  double latitude;
  double longitude;

  _Location__isset __isset;

  void __set_latitude(const double val);

  void __set_longitude(const double val);

  bool operator == (const Location & rhs) const
  {
    if (!(latitude == rhs.latitude))
      return false;
    if (!(longitude == rhs.longitude))
      return false;
    return true;
  }
  bool operator != (const Location &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Location & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Location &a, Location &b);

std::ostream& operator<<(std::ostream& out, const Location& obj);

typedef struct _SocialNet__isset {
  _SocialNet__isset() : type(false) {}
  bool type :1;
} _SocialNet__isset;

class SocialNet : public virtual ::apache::thrift::TBase {
 public:

  SocialNet(const SocialNet&);
  SocialNet& operator=(const SocialNet&);
  SocialNet() : type((SocialNetType::type)0) {
  }

  virtual ~SocialNet() throw();
  SocialNetType::type type;

  _SocialNet__isset __isset;

  void __set_type(const SocialNetType::type val);

  bool operator == (const SocialNet & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const SocialNet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SocialNet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SocialNet &a, SocialNet &b);

std::ostream& operator<<(std::ostream& out, const SocialNet& obj);

typedef struct _Symbol__isset {
  _Symbol__isset() : name(false), measure(false), tags(false), kv(false) {}
  bool name :1;
  bool measure :1;
  bool tags :1;
  bool kv :1;
} _Symbol__isset;

class Symbol : public virtual ::apache::thrift::TBase {
 public:

  Symbol(const Symbol&);
  Symbol& operator=(const Symbol&);
  Symbol() : name(), measure() {
  }

  virtual ~Symbol() throw();
  std::string name;
  std::string measure;
  std::set<std::string>  tags;
  std::map<std::string, std::string>  kv;

  _Symbol__isset __isset;

  void __set_name(const std::string& val);

  void __set_measure(const std::string& val);

  void __set_tags(const std::set<std::string> & val);

  void __set_kv(const std::map<std::string, std::string> & val);

  bool operator == (const Symbol & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(measure == rhs.measure))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(kv == rhs.kv))
      return false;
    return true;
  }
  bool operator != (const Symbol &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Symbol & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Symbol &a, Symbol &b);

std::ostream& operator<<(std::ostream& out, const Symbol& obj);

typedef struct _Wallet__isset {
  _Wallet__isset() : name(false), currency(false), volume(false) {}
  bool name :1;
  bool currency :1;
  bool volume :1;
} _Wallet__isset;

class Wallet : public virtual ::apache::thrift::TBase {
 public:

  Wallet(const Wallet&);
  Wallet& operator=(const Wallet&);
  Wallet() : name(), volume(0) {
  }

  virtual ~Wallet() throw();
  std::string name;
  Symbol currency;
  Volume volume;

  _Wallet__isset __isset;

  void __set_name(const std::string& val);

  void __set_currency(const Symbol& val);

  void __set_volume(const Volume val);

  bool operator == (const Wallet & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(currency == rhs.currency))
      return false;
    if (!(volume == rhs.volume))
      return false;
    return true;
  }
  bool operator != (const Wallet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Wallet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Wallet &a, Wallet &b);

std::ostream& operator<<(std::ostream& out, const Wallet& obj);

typedef struct _UserAttributes__isset {
  _UserAttributes__isset() : loc(false), active(false), social(false) {}
  bool loc :1;
  bool active :1;
  bool social :1;
} _UserAttributes__isset;

class UserAttributes : public virtual ::apache::thrift::TBase {
 public:

  UserAttributes(const UserAttributes&);
  UserAttributes& operator=(const UserAttributes&);
  UserAttributes() : active(0) {
  }

  virtual ~UserAttributes() throw();
  Location loc;
  bool active;
  std::map<std::string, SocialNet>  social;

  _UserAttributes__isset __isset;

  void __set_loc(const Location& val);

  void __set_active(const bool val);

  void __set_social(const std::map<std::string, SocialNet> & val);

  bool operator == (const UserAttributes & rhs) const
  {
    if (!(loc == rhs.loc))
      return false;
    if (!(active == rhs.active))
      return false;
    if (!(social == rhs.social))
      return false;
    return true;
  }
  bool operator != (const UserAttributes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserAttributes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UserAttributes &a, UserAttributes &b);

std::ostream& operator<<(std::ostream& out, const UserAttributes& obj);

typedef struct _User__isset {
  _User__isset() : id(false), username(false), kv(false), kvs(false), wallets(false), level(false), attributes(false) {}
  bool id :1;
  bool username :1;
  bool kv :1;
  bool kvs :1;
  bool wallets :1;
  bool level :1;
  bool attributes :1;
} _User__isset;

class User : public virtual ::apache::thrift::TBase {
 public:

  User(const User&);
  User& operator=(const User&);
  User() : id(0), username(), level((PrivilegeLevel::type)0) {
  }

  virtual ~User() throw();
  ID id;
  std::string username;
  std::map<std::string, std::string>  kv;
  std::map<std::string, std::map<std::string, std::string> >  kvs;
  std::map<Symbol, Wallet>  wallets;
  PrivilegeLevel::type level;
  UserAttributes attributes;

  _User__isset __isset;

  void __set_id(const ID val);

  void __set_username(const std::string& val);

  void __set_kv(const std::map<std::string, std::string> & val);

  void __set_kvs(const std::map<std::string, std::map<std::string, std::string> > & val);

  void __set_wallets(const std::map<Symbol, Wallet> & val);

  void __set_level(const PrivilegeLevel::type val);

  void __set_attributes(const UserAttributes& val);

  bool operator == (const User & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(kv == rhs.kv))
      return false;
    if (!(kvs == rhs.kvs))
      return false;
    if (!(wallets == rhs.wallets))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(User &a, User &b);

std::ostream& operator<<(std::ostream& out, const User& obj);

typedef struct _Order__isset {
  _Order__isset() : id(false), symbol(false), symbolDst(false), price(false), takeProfit(false), stopLoss(false), swap(false), profit(false), volume(false), time(false), state(false), type(false), user(false) {}
  bool id :1;
  bool symbol :1;
  bool symbolDst :1;
  bool price :1;
  bool takeProfit :1;
  bool stopLoss :1;
  bool swap :1;
  bool profit :1;
  bool volume :1;
  bool time :1;
  bool state :1;
  bool type :1;
  bool user :1;
} _Order__isset;

class Order : public virtual ::apache::thrift::TBase {
 public:

  Order(const Order&);
  Order& operator=(const Order&);
  Order() : id(0), price(0), takeProfit(0), stopLoss(0), swap(0), profit(0), volume(0), state((OrderState::type)0), type((OrderType::type)0) {
  }

  virtual ~Order() throw();
  ID id;
  Symbol symbol;
  Symbol symbolDst;
  Price price;
  Price takeProfit;
  Price stopLoss;
  Price swap;
  Price profit;
  Volume volume;
  std::map<OrderState::type, Timestamp>  time;
  OrderState::type state;
  OrderType::type type;
  User user;

  _Order__isset __isset;

  void __set_id(const ID val);

  void __set_symbol(const Symbol& val);

  void __set_symbolDst(const Symbol& val);

  void __set_price(const Price val);

  void __set_takeProfit(const Price val);

  void __set_stopLoss(const Price val);

  void __set_swap(const Price val);

  void __set_profit(const Price val);

  void __set_volume(const Volume val);

  void __set_time(const std::map<OrderState::type, Timestamp> & val);

  void __set_state(const OrderState::type val);

  void __set_type(const OrderType::type val);

  void __set_user(const User& val);

  bool operator == (const Order & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(symbol == rhs.symbol))
      return false;
    if (!(symbolDst == rhs.symbolDst))
      return false;
    if (!(price == rhs.price))
      return false;
    if (!(takeProfit == rhs.takeProfit))
      return false;
    if (!(stopLoss == rhs.stopLoss))
      return false;
    if (!(swap == rhs.swap))
      return false;
    if (!(profit == rhs.profit))
      return false;
    if (!(volume == rhs.volume))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const Order &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Order & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Order &a, Order &b);

std::ostream& operator<<(std::ostream& out, const Order& obj);

typedef struct _Transaction__isset {
  _Transaction__isset() : id(false), sell(false), buy(false), price(false), volume(false), state(false), time(false) {}
  bool id :1;
  bool sell :1;
  bool buy :1;
  bool price :1;
  bool volume :1;
  bool state :1;
  bool time :1;
} _Transaction__isset;

class Transaction : public virtual ::apache::thrift::TBase {
 public:

  Transaction(const Transaction&);
  Transaction& operator=(const Transaction&);
  Transaction() : id(0), price(0), volume(0), state((TransactionState::type)0) {
  }

  virtual ~Transaction() throw();
  ID id;
  Order sell;
  Order buy;
  Price price;
  Volume volume;
  TransactionState::type state;
  std::map<TransactionState::type, Timestamp>  time;

  _Transaction__isset __isset;

  void __set_id(const ID val);

  void __set_sell(const Order& val);

  void __set_buy(const Order& val);

  void __set_price(const Price val);

  void __set_volume(const Volume val);

  void __set_state(const TransactionState::type val);

  void __set_time(const std::map<TransactionState::type, Timestamp> & val);

  bool operator == (const Transaction & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(sell == rhs.sell))
      return false;
    if (!(buy == rhs.buy))
      return false;
    if (!(price == rhs.price))
      return false;
    if (!(volume == rhs.volume))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(time == rhs.time))
      return false;
    return true;
  }
  bool operator != (const Transaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Transaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Transaction &a, Transaction &b);

std::ostream& operator<<(std::ostream& out, const Transaction& obj);

typedef struct _MarketData__isset {
  _MarketData__isset() : symbol(false), price(false), volume(false), timestamp(false) {}
  bool symbol :1;
  bool price :1;
  bool volume :1;
  bool timestamp :1;
} _MarketData__isset;

class MarketData : public virtual ::apache::thrift::TBase {
 public:

  MarketData(const MarketData&);
  MarketData& operator=(const MarketData&);
  MarketData() : volume(0), timestamp(0) {
  }

  virtual ~MarketData() throw();
  Symbol symbol;
  std::map<std::string, double>  price;
  double volume;
  Timestamp timestamp;

  _MarketData__isset __isset;

  void __set_symbol(const Symbol& val);

  void __set_price(const std::map<std::string, double> & val);

  void __set_volume(const double val);

  void __set_timestamp(const Timestamp val);

  bool operator == (const MarketData & rhs) const
  {
    if (!(symbol == rhs.symbol))
      return false;
    if (!(price == rhs.price))
      return false;
    if (!(volume == rhs.volume))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const MarketData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MarketData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MarketData &a, MarketData &b);

std::ostream& operator<<(std::ostream& out, const MarketData& obj);

typedef struct _OrderBook__isset {
  _OrderBook__isset() : id(false), ordersOpen(false), orders(false), orderIdx(false), transactions(false), md(false) {}
  bool id :1;
  bool ordersOpen :1;
  bool orders :1;
  bool orderIdx :1;
  bool transactions :1;
  bool md :1;
} _OrderBook__isset;

class OrderBook : public virtual ::apache::thrift::TBase {
 public:

  OrderBook(const OrderBook&);
  OrderBook& operator=(const OrderBook&);
  OrderBook() : id(0) {
  }

  virtual ~OrderBook() throw();
  int64_t id;
  TOrdersFull ordersOpen;
  std::map<std::string, TOrders>  orders;
  std::map<std::string, IdIdx>  orderIdx;
  std::map<std::string, TTransactions>  transactions;
  std::map<std::string, TMarketDataPoint>  md;

  _OrderBook__isset __isset;

  void __set_id(const int64_t val);

  void __set_ordersOpen(const TOrdersFull& val);

  void __set_orders(const std::map<std::string, TOrders> & val);

  void __set_orderIdx(const std::map<std::string, IdIdx> & val);

  void __set_transactions(const std::map<std::string, TTransactions> & val);

  void __set_md(const std::map<std::string, TMarketDataPoint> & val);

  bool operator == (const OrderBook & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(ordersOpen == rhs.ordersOpen))
      return false;
    if (!(orders == rhs.orders))
      return false;
    if (!(orderIdx == rhs.orderIdx))
      return false;
    if (!(transactions == rhs.transactions))
      return false;
    if (!(md == rhs.md))
      return false;
    return true;
  }
  bool operator != (const OrderBook &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OrderBook & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OrderBook &a, OrderBook &b);

std::ostream& operator<<(std::ostream& out, const OrderBook& obj);

typedef struct _TMSpec__isset {
  _TMSpec__isset() : owner(false), type(false), desc(false), host(false), port(false), cmd(false), link(false), guid(false), timeCreation(false) {}
  bool owner :1;
  bool type :1;
  bool desc :1;
  bool host :1;
  bool port :1;
  bool cmd :1;
  bool link :1;
  bool guid :1;
  bool timeCreation :1;
} _TMSpec__isset;

class TMSpec : public virtual ::apache::thrift::TBase {
 public:

  TMSpec(const TMSpec&);
  TMSpec& operator=(const TMSpec&);
  TMSpec() : type(), desc(), host(), port(0), link(), guid(), timeCreation(0) {
  }

  virtual ~TMSpec() throw();
  User owner;
  std::string type;
  std::string desc;
  std::string host;
  int32_t port;
  std::vector<std::string>  cmd;
  std::string link;
  Guid guid;
  Timestamp timeCreation;

  _TMSpec__isset __isset;

  void __set_owner(const User& val);

  void __set_type(const std::string& val);

  void __set_desc(const std::string& val);

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_cmd(const std::vector<std::string> & val);

  void __set_link(const std::string& val);

  void __set_guid(const Guid& val);

  void __set_timeCreation(const Timestamp val);

  bool operator == (const TMSpec & rhs) const
  {
    if (!(owner == rhs.owner))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(desc == rhs.desc))
      return false;
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(cmd == rhs.cmd))
      return false;
    if (!(link == rhs.link))
      return false;
    if (!(guid == rhs.guid))
      return false;
    if (!(timeCreation == rhs.timeCreation))
      return false;
    return true;
  }
  bool operator != (const TMSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMSpec &a, TMSpec &b);

std::ostream& operator<<(std::ostream& out, const TMSpec& obj);

typedef struct _TradeMachine__isset {
  _TradeMachine__isset() : spec(false), book(false), users(false), symbolsSrc(false), symbolsDst(false) {}
  bool spec :1;
  bool book :1;
  bool users :1;
  bool symbolsSrc :1;
  bool symbolsDst :1;
} _TradeMachine__isset;

class TradeMachine : public virtual ::apache::thrift::TBase {
 public:

  TradeMachine(const TradeMachine&);
  TradeMachine& operator=(const TradeMachine&);
  TradeMachine() {
  }

  virtual ~TradeMachine() throw();
  TMSpec spec;
  OrderBook book;
  std::vector<User>  users;
  std::vector<Symbol>  symbolsSrc;
  std::vector<Symbol>  symbolsDst;

  _TradeMachine__isset __isset;

  void __set_spec(const TMSpec& val);

  void __set_book(const OrderBook& val);

  void __set_users(const std::vector<User> & val);

  void __set_symbolsSrc(const std::vector<Symbol> & val);

  void __set_symbolsDst(const std::vector<Symbol> & val);

  bool operator == (const TradeMachine & rhs) const
  {
    if (!(spec == rhs.spec))
      return false;
    if (!(book == rhs.book))
      return false;
    if (!(users == rhs.users))
      return false;
    if (!(symbolsSrc == rhs.symbolsSrc))
      return false;
    if (!(symbolsDst == rhs.symbolsDst))
      return false;
    return true;
  }
  bool operator != (const TradeMachine &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TradeMachine & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TradeMachine &a, TradeMachine &b);

std::ostream& operator<<(std::ostream& out, const TradeMachine& obj);

}}} // namespace

#endif
